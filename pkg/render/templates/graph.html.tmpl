<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Domino Network Map</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600&family=Outfit:wght@300;400;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-primary: #0a0e14;
            --bg-secondary: #121820;
            --bg-tertiary: #1a222d;
            --accent-cyan: #39bae6;
            --accent-orange: #ff8f40;
            --accent-green: #7fd962;
            --accent-purple: #c792ea;
            --accent-red: #f07178;
            --accent-yellow: #ffcc66;
            --text-primary: #e6e6e6;
            --text-secondary: #626a73;
            --border-color: #2a3444;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Outfit', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            overflow: hidden;
            height: 100vh;
        }
        
        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 56px;
            background: linear-gradient(180deg, var(--bg-secondary) 0%, rgba(18, 24, 32, 0.95) 100%);
            backdrop-filter: blur(12px);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            padding: 0 24px;
            z-index: 100;
            gap: 24px;
        }
        
        .logo {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .logo-icon {
            width: 32px;
            height: 32px;
            background: linear-gradient(135deg, var(--accent-cyan), var(--accent-purple));
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .logo-icon svg {
            width: 20px;
            height: 20px;
        }
        
        .logo-text {
            font-weight: 700;
            font-size: 18px;
            letter-spacing: -0.02em;
        }
        
        .stats {
            display: flex;
            gap: 16px;
            margin-left: auto;
        }
        
        .stat {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 12px;
            background: var(--bg-tertiary);
            border-radius: 6px;
            font-size: 13px;
        }
        
        .stat-value {
            font-family: 'JetBrains Mono', monospace;
            font-weight: 600;
            color: var(--accent-cyan);
        }
        
        .stat-label {
            color: var(--text-secondary);
        }
        
        .controls {
            display: flex;
            gap: 8px;
        }
        
        .btn {
            padding: 8px 16px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-primary);
            font-family: 'Outfit', sans-serif;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.15s ease;
        }
        
        .btn:hover {
            background: var(--border-color);
            border-color: var(--accent-cyan);
        }
        
        .btn-primary {
            background: linear-gradient(135deg, var(--accent-cyan), var(--accent-purple));
            border: none;
            font-weight: 600;
        }
        
        .btn-primary:hover {
            opacity: 0.9;
            transform: translateY(-1px);
        }
        
        #canvas-container {
            position: fixed;
            top: 56px;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 20% 30%, rgba(57, 186, 230, 0.03) 0%, transparent 50%),
                radial-gradient(circle at 80% 70%, rgba(199, 146, 234, 0.03) 0%, transparent 50%),
                var(--bg-primary);
        }
        
        #canvas {
            width: 100%;
            height: 100%;
        }
        
        .tooltip {
            position: fixed;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 12px 16px;
            font-size: 13px;
            max-width: 400px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.15s ease;
            z-index: 200;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
        }
        
        .tooltip.visible {
            opacity: 1;
        }
        
        .tooltip-title {
            font-weight: 600;
            font-size: 14px;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .tooltip-badge {
            font-size: 11px;
            padding: 2px 8px;
            border-radius: 4px;
            font-family: 'JetBrains Mono', monospace;
            font-weight: 600;
        }
        
        .badge-deployment { background: rgba(127, 217, 98, 0.2); color: var(--accent-green); }
        .badge-statefulset { background: rgba(199, 146, 234, 0.2); color: var(--accent-purple); }
        .badge-daemonset { background: rgba(255, 143, 64, 0.2); color: var(--accent-orange); }
        .badge-port { background: rgba(57, 186, 230, 0.2); color: var(--accent-cyan); }
        
        .tooltip-row {
            display: flex;
            gap: 8px;
            margin-top: 6px;
        }
        
        .tooltip-label {
            color: var(--text-secondary);
            min-width: 70px;
        }
        
        .tooltip-value {
            font-family: 'JetBrains Mono', monospace;
            color: var(--text-primary);
        }
        
        .tooltip-rule {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid var(--border-color);
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            color: var(--accent-yellow);
            line-height: 1.5;
        }
        
        .legend {
            position: fixed;
            bottom: 24px;
            left: 24px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 16px 20px;
            z-index: 100;
        }
        
        .legend-title {
            font-size: 12px;
            color: var(--text-secondary);
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        
        .legend-items {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 13px;
        }
        
        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 3px;
        }
        
        .minimap {
            position: fixed;
            bottom: 24px;
            right: 24px;
            width: 180px;
            height: 120px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            overflow: hidden;
            z-index: 100;
        }
        
        #minimap-canvas {
            width: 100%;
            height: 100%;
        }
        
        .search-container {
            position: relative;
        }
        
        .search-input {
            padding: 8px 12px 8px 36px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-primary);
            font-family: 'Outfit', sans-serif;
            font-size: 13px;
            width: 220px;
            outline: none;
            transition: all 0.15s ease;
        }
        
        .search-input:focus {
            border-color: var(--accent-cyan);
            background: var(--bg-secondary);
        }
        
        .search-input::placeholder {
            color: var(--text-secondary);
        }
        
        .search-icon {
            position: absolute;
            left: 12px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--text-secondary);
        }
        
        .selection-info {
            padding: 8px 16px;
            background: linear-gradient(135deg, rgba(57, 186, 230, 0.2), rgba(199, 146, 234, 0.2));
            border: 1px solid var(--accent-cyan);
            border-radius: 6px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 13px;
            color: var(--accent-cyan);
        }
    </style>
</head>
<body>
    <header class="header">
        <div class="logo">
            <div class="logo-icon">
                <svg viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2">
                    <circle cx="12" cy="12" r="3"/>
                    <path d="M12 2v4m0 12v4M2 12h4m12 0h4"/>
                    <path d="M4.93 4.93l2.83 2.83m8.48 8.48l2.83 2.83M4.93 19.07l2.83-2.83m8.48-8.48l2.83-2.83"/>
                </svg>
            </div>
            <span class="logo-text">dnmap</span>
        </div>
        
        <div class="search-container">
            <svg class="search-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="11" cy="11" r="8"/>
                <path d="M21 21l-4.35-4.35"/>
            </svg>
            <input type="text" class="search-input" placeholder="Search workloads..." id="search-input">
        </div>
        
        <div class="stats">
            <div class="stat">
                <span class="stat-value" id="node-count">0</span>
                <span class="stat-label">workloads</span>
            </div>
            <div class="stat">
                <span class="stat-value" id="edge-count">0</span>
                <span class="stat-label">connections</span>
            </div>
        </div>
        
        <div class="selection-info" id="selection-info" style="display: none;"></div>
        
        <div class="controls">
            <button class="btn" onclick="clearSelection()">Clear Selection</button>
            <button class="btn" id="hover-edges-btn" onclick="toggleHoverEdges()">Hover Edges: ON</button>
            <button class="btn" onclick="resetView()">Reset View</button>
            <button class="btn" onclick="reLayout()">Re-Layout</button>
            <button class="btn btn-primary" onclick="exportPNG()">Export PNG</button>
        </div>
    </header>
    
    <div id="canvas-container">
        <canvas id="canvas"></canvas>
    </div>
    
    <div class="tooltip" id="tooltip"></div>
    
    <div class="legend">
        <div class="legend-title">Workload Types</div>
        <div class="legend-items">
            <div class="legend-item">
                <div class="legend-color" style="background: #7fd962;"></div>
                <span>Deployment</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #c792ea;"></div>
                <span>StatefulSet</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #ff8f40;"></div>
                <span>DaemonSet</span>
            </div>
        </div>
        <div class="legend-title" style="margin-top: 12px;">Edges (click workload)</div>
        <div class="legend-items">
            <div class="legend-item">
                <div class="legend-color" style="background: #7fd962;"></div>
                <span>Outbound</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #ff8f40;"></div>
                <span>Inbound</span>
            </div>
        </div>
    </div>
    
    <div class="minimap">
        <canvas id="minimap-canvas"></canvas>
    </div>
    
    <script>
    try {
    console.log('dnmap: script starting');
    const graphData = {{.GraphData}};
    console.log('dnmap: graphData loaded, nodes:', graphData.nodes?.length, 'edges:', graphData.edges?.length);
    
    // Canvas setup
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const minimapCanvas = document.getElementById('minimap-canvas');
    const minimapCtx = minimapCanvas.getContext('2d');
    const tooltip = document.getElementById('tooltip');
    
    let width, height;
    let dpr = window.devicePixelRatio || 1;
    
    // View state (ensure initial values are always valid numbers)
    let panX = 0;
    let panY = 0;
    let zoom = 1;
    let isDragging = false;
    let isPanning = false;
    let dragNode = null;
    let dragOffsetX = 0, dragOffsetY = 0;
    let lastMouseX = 0, lastMouseY = 0;
    
    // Colors
    const colors = {
        Deployment: '#7fd962',
        StatefulSet: '#c792ea',
        DaemonSet: '#ff8f40',
        Pod: '#f07178',
        port: '#39bae6',
        edge: 'rgba(57, 186, 230, 0.4)',
        edgeHover: 'rgba(57, 186, 230, 0.8)',
    };
    
    // Node dimensions
    const WORKLOAD_WIDTH = 140;
    const WORKLOAD_HEADER_HEIGHT = 36; // Space for label + namespace
    const PORT_WIDTH = 32;
    const PORT_HEIGHT = 18;
    const PORT_GAP = 4; // Gap between ports
    
    class GraphNode {
        constructor(data) {
            this.data = data;
            this.x = (Math.random() * 800 - 400) || 0;
            this.y = (Math.random() * 600 - 300) || 0;
            this.vx = 0;
            this.vy = 0;
            this.fixed = false;
            // Dimensions (height calculated later for workloads based on ports)
            if (data.type === 'port') {
                this.width = PORT_WIDTH;
                this.height = PORT_HEIGHT;
            } else {
                this.width = WORKLOAD_WIDTH;
                this.height = WORKLOAD_HEADER_HEIGHT + PORT_HEIGHT; // Minimum height, updated later
            }
        }
    }
    
    // Calculate workload height based on number of ports
    function updateWorkloadHeight(workloadNode, portCount) {
        const portsHeight = portCount * PORT_HEIGHT + (portCount - 1) * PORT_GAP;
        workloadNode.height = WORKLOAD_HEADER_HEIGHT + 8 + Math.max(portsHeight, PORT_HEIGHT) + 8; // 8px padding top and bottom
    }
    
    // Helper to check if a number is finite
    function isFiniteNum(n) {
        return typeof n === 'number' && isFinite(n);
    }
    
    // Initialize nodes
    const nodes = new Map();
    const workloadNodes = [];
    const portNodes = [];
    
    graphData.nodes.forEach(n => {
        const node = new GraphNode(n);
        nodes.set(n.id, node);
        if (n.type === 'workload') {
            workloadNodes.push(node);
        } else {
            portNodes.push(node);
        }
    });
    
    // Position port nodes relative to their parents
    portNodes.forEach(portNode => {
        const parent = nodes.get(portNode.data.parent);
        if (parent && isFiniteNum(parent.x) && isFiniteNum(parent.y)) {
            portNode.x = parent.x + (Math.random() - 0.5) * 60;
            portNode.y = parent.y + (Math.random() - 0.5) * 60;
        } else {
            // Fallback to origin if parent not found or invalid
            portNode.x = (Math.random() - 0.5) * 100;
            portNode.y = (Math.random() - 0.5) * 100;
        }
    });
    
    // Edges
    const edges = graphData.edges.map(e => ({
        ...e,
        sourceNode: nodes.get(e.source),
        targetNode: nodes.get(e.target)
    })).filter(e => e.sourceNode && e.targetNode);
    
    // Update stats
    document.getElementById('node-count').textContent = workloadNodes.length;
    document.getElementById('edge-count').textContent = edges.length;
    
    // Debug logging
    console.log('dnmap: loaded', workloadNodes.length, 'workloads,', portNodes.length, 'ports,', edges.length, 'edges');
    
    // Grid layout function - groups by namespace, no overlaps
    function applyGridLayout() {
        // First pass: update all workload heights based on port count
        workloadNodes.forEach(node => {
            const ports = getPortsForWorkload(node);
            updateWorkloadHeight(node, ports.length || 1);
        });
        
        // Group workloads by namespace
        const byNamespace = {};
        workloadNodes.forEach(node => {
            const ns = node.data.namespace || 'default';
            if (!byNamespace[ns]) byNamespace[ns] = [];
            byNamespace[ns].push(node);
        });
        
        const namespaces = Object.keys(byNamespace).sort();
        const serviceWidth = PORT_WIDTH * 3.5;
        const nodeSpacing = WORKLOAD_WIDTH + serviceWidth; // Account for service width on right
        const namespaceGap = 50;
        const nodesPerRow = Math.ceil(Math.sqrt(workloadNodes.length / namespaces.length)) + 2;
        
        let currentY = 0;
        
        namespaces.forEach((ns, nsIdx) => {
            const nsNodes = byNamespace[ns];
            
            // Organize into rows
            const rows = [];
            for (let i = 0; i < nsNodes.length; i += nodesPerRow) {
                rows.push(nsNodes.slice(i, i + nodesPerRow));
            }
            
            rows.forEach((rowNodes, rowIdx) => {
                // Find max height in this row
                const maxHeight = Math.max(...rowNodes.map(n => n.height));
                
                rowNodes.forEach((node, col) => {
                    node.x = col * nodeSpacing;
                    node.y = currentY + maxHeight / 2; // Center vertically in row
                    node.vx = 0;
                    node.vy = 0;
                });
                
                currentY += maxHeight + 20; // Move to next row
            });
            
            currentY += namespaceGap;
        });
        
        // Update port positions
        workloadNodes.forEach(node => {
            updatePortPositions(node);
        });
        
        console.log('dnmap: applied grid layout for', namespaces.length, 'namespaces');
    }
    
    // Apply initial layout
    applyGridLayout();
    
    function resize() {
        const rect = canvas.parentElement.getBoundingClientRect();
        width = rect.width || 800;
        height = rect.height || 600;
        
        // Ensure dimensions are valid
        if (!isFiniteNum(width) || width <= 0) width = 800;
        if (!isFiniteNum(height) || height <= 0) height = 600;
        
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        canvas.style.width = width + 'px';
        canvas.style.height = height + 'px';
        
        // Reset transform before scaling (fixes compounding scale issue)
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.scale(dpr, dpr);
        
        minimapCanvas.width = 180 * dpr;
        minimapCanvas.height = 120 * dpr;
        minimapCtx.setTransform(1, 0, 0, 1, 0, 0);
        minimapCtx.scale(dpr, dpr);
        
        // Center view if first resize
        if (panX === 0 && panY === 0) {
            panX = width / 2;
            panY = height / 2;
        }
        
        console.log('dnmap resize: width=', width, 'height=', height, 'dpr=', dpr);
    }
    
    function worldToScreen(x, y) {
        const sx = (x || 0) * (zoom || 1) + (panX || 0);
        const sy = (y || 0) * (zoom || 1) + (panY || 0);
        return {
            x: isFiniteNum(sx) ? sx : 0,
            y: isFiniteNum(sy) ? sy : 0
        };
    }
    
    function screenToWorld(x, y) {
        return {
            x: (x - panX) / zoom,
            y: (y - panY) / zoom
        };
    }
    
    
    let hoveredNode = null;
    let hoveredEdge = null;
    let searchTerm = '';
    let selectedNode = null; // Currently selected workload
    let showEdgesOnHover = true; // Toggle for hover edge preview
    
    let frameCount = 0;
    function draw() {
        frameCount++;
        
        // Log every 60 frames (about once per second)
        if (frameCount % 60 === 1) {
            const validNodes = workloadNodes.filter(n => isFiniteNum(n.x) && isFiniteNum(n.y)).length;
            console.log('dnmap frame', frameCount, ': validNodes=', validNodes, '/', workloadNodes.length, 
                        'panX=', panX, 'panY=', panY, 'zoom=', zoom);
            if (workloadNodes.length > 0) {
                const n = workloadNodes[0];
                const s = worldToScreen(n.x, n.y);
                console.log('  node0: world=', n.x.toFixed(1), n.y.toFixed(1), 
                            'screen=', s.x.toFixed(1), s.y.toFixed(1));
            }
        }
        
        ctx.clearRect(0, 0, width, height);
        
        // Draw grid
        ctx.strokeStyle = 'rgba(42, 52, 68, 0.3)';
        ctx.lineWidth = 1;
        const gridSize = 50 * zoom;
        const offsetX = panX % gridSize;
        const offsetY = panY % gridSize;
        
        ctx.beginPath();
        for (let x = offsetX; x < width; x += gridSize) {
            ctx.moveTo(x, 0);
            ctx.lineTo(x, height);
        }
        for (let y = offsetY; y < height; y += gridSize) {
            ctx.moveTo(0, y);
            ctx.lineTo(width, y);
        }
        ctx.stroke();
        
        // Draw edges for selected node and/or hovered node (if enabled)
        const hoveredWorkload = (showEdgesOnHover && hoveredNode && hoveredNode.data.type === 'workload') ? hoveredNode : null;
        const hoveredPort = (showEdgesOnHover && hoveredNode && hoveredNode.data.type === 'port') ? hoveredNode : null;
        const nodesToShowEdges = [];
        
        // Handle selected node (workload or port)
        if (selectedNode) {
            if (selectedNode.data.type === 'workload') {
                nodesToShowEdges.push({ node: selectedNode, transparent: false, filterPort: null });
            } else if (selectedNode.data.type === 'port') {
                const parentWorkload = nodes.get(selectedNode.data.parent);
                if (parentWorkload) nodesToShowEdges.push({ node: parentWorkload, transparent: false, filterPort: selectedNode });
            }
        }
        
        // Handle hovered workload (if different from selected)
        if (hoveredWorkload && hoveredWorkload !== selectedNode) {
            nodesToShowEdges.push({ node: hoveredWorkload, transparent: true, filterPort: null });
        }
        
        // Handle hovered port (if different from selected)
        if (hoveredPort && hoveredPort !== selectedNode) {
            const parentWorkload = nodes.get(hoveredPort.data.parent);
            if (parentWorkload) nodesToShowEdges.push({ node: parentWorkload, transparent: true, filterPort: hoveredPort });
        }
        
        nodesToShowEdges.forEach(({ node: activeNode, transparent, filterPort }) => {
            const activeWorkloadId = activeNode.data.id;
            
            edges.forEach(edge => {
                const source = edge.sourceNode;
                const target = edge.targetNode;
                
                // Only show edges connected to this workload
                const targetParentId = target.data.parent;
                const isConnected = (source.data.id === activeWorkloadId) || (targetParentId === activeWorkloadId);
                if (!isConnected) return;
                
                // If filtering by specific port, only show edges to/from that port
                if (filterPort) {
                    const isPortMatch = (target.data.id === filterPort.data.id) || (source.data.id === filterPort.data.id);
                    if (!isPortMatch) return;
                }
                
                // Skip if source or target nodes are invalid
                if (!source || !target) return;
                if (!isFiniteNum(source.x) || !isFiniteNum(source.y)) return;
                if (!isFiniteNum(target.x) || !isFiniteNum(target.y)) return;
                
                // Calculate connection points:
                // - Outbound: from source workload's top center
                // - Inbound: to target port's right side
                const isOutbound = source.data.id === activeWorkloadId;
                
                // Source point: top center of workload
                const sourceHeight = source.height || WORKLOAD_HEADER_HEIGHT;
                const sourceX = source.x;
                const sourceY = source.y - sourceHeight / 2;
                
                // Target point: right side of port
                const targetX = target.x + PORT_WIDTH / 2;
                const targetY = target.y;
                
                const start = worldToScreen(sourceX, sourceY);
                const end = worldToScreen(targetX, targetY);
                
                // Skip if screen coordinates are invalid
                if (!isFiniteNum(start.x) || !isFiniteNum(start.y)) return;
                if (!isFiniteNum(end.x) || !isFiniteNum(end.y)) return;
                
                const isHovered = hoveredEdge === edge;
                const baseOpacity = transparent ? 0.3 : 0.6;
                const opacity = isHovered ? 1 : baseOpacity;
                const color = isOutbound ? 'rgba(127, 217, 98, ' : 'rgba(255, 143, 64, '; // green outbound, orange inbound
                
                // Draw curved line with vertical start
                ctx.beginPath();
                const dx = end.x - start.x;
                const dy = end.y - start.y;
                
                // Control points for a nice curve
                // Start going up from source, then curve to target
                const ctrl1X = start.x;
                const ctrl1Y = start.y - Math.abs(dy) * 0.3;
                const ctrl2X = end.x + Math.abs(dx) * 0.3;
                const ctrl2Y = end.y;
                
                if (!isFiniteNum(ctrl1X) || !isFiniteNum(ctrl1Y) || !isFiniteNum(ctrl2X) || !isFiniteNum(ctrl2Y)) return;
                
                ctx.moveTo(start.x, start.y);
                ctx.bezierCurveTo(ctrl1X, ctrl1Y, ctrl2X, ctrl2Y, end.x, end.y);
                ctx.strokeStyle = isHovered ? color + '1)' : color + opacity + ')';
                ctx.lineWidth = isHovered ? 3 : (transparent ? 1.5 : 2);
                ctx.stroke();
            });
        });
        
        
        // Draw workload nodes (rectangles with dynamic height)
        workloadNodes.forEach(node => {
            if (!isFiniteNum(node.x) || !isFiniteNum(node.y)) return;
            
            const screen = worldToScreen(node.x, node.y);
            if (!isFiniteNum(screen.x) || !isFiniteNum(screen.y)) return;
            
            const isHovered = hoveredNode === node;
            const isSearchMatch = searchTerm && node.data.label && node.data.label.toLowerCase().includes(searchTerm.toLowerCase());
            const isSelected = selectedNode === node;
            
            const w = WORKLOAD_WIDTH * zoom;
            const h = node.height * zoom; // Dynamic height based on ports
            const headerH = WORKLOAD_HEADER_HEIGHT * zoom;
            const color = colors[node.data.kind] || colors.Deployment;
            
            // Glow effect for selected or hovered
            if (isSelected || isHovered) {
                ctx.shadowColor = color;
                ctx.shadowBlur = 20;
            }
            
            // Search match: bright yellow glow
            if (isSearchMatch) {
                ctx.shadowColor = '#ffcc00';
                ctx.shadowBlur = 30;
            }
            
            // Workload body
            ctx.beginPath();
            roundRect(ctx, screen.x - w/2, screen.y - h/2, w, h, 6 * zoom);
            
            // Search match gets a highlighted background
            if (isSearchMatch) {
                const fillGradient = ctx.createLinearGradient(screen.x - w/2, screen.y - h/2, screen.x + w/2, screen.y + h/2);
                fillGradient.addColorStop(0, '#ffcc0040');
                fillGradient.addColorStop(1, '#ffcc0020');
                ctx.fillStyle = fillGradient;
            } else {
                const fillGradient = ctx.createLinearGradient(screen.x - w/2, screen.y - h/2, screen.x + w/2, screen.y + h/2);
                fillGradient.addColorStop(0, color + '20');
                fillGradient.addColorStop(1, color + '08');
                ctx.fillStyle = fillGradient;
            }
            ctx.fill();
            
            // Border - yellow for search match
            if (isSearchMatch) {
                ctx.strokeStyle = '#ffcc00';
                ctx.lineWidth = 3;
            } else {
                ctx.strokeStyle = (isSelected || isHovered) ? color : color + '80';
                ctx.lineWidth = isSelected ? 3 : (isHovered ? 2 : 1);
            }
            ctx.stroke();
            
            // Header separator line
            ctx.beginPath();
            ctx.moveTo(screen.x - w/2, screen.y - h/2 + headerH);
            ctx.lineTo(screen.x + w/2, screen.y - h/2 + headerH);
            ctx.strokeStyle = color + '40';
            ctx.lineWidth = 1;
            ctx.stroke();
            
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            
            // Label at top center (in header area)
            const fontSize = 11 * zoom;
            if (fontSize >= 6) { // Only show if readable
                ctx.font = '600 ' + fontSize + 'px Outfit';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'top';
                
                const label = node.data.label || '';
                // Truncate to fit width
                const maxWidth = w - 10 * zoom;
                let displayLabel = label;
                while (ctx.measureText(displayLabel).width > maxWidth && displayLabel.length > 3) {
                    displayLabel = displayLabel.slice(0, -2) + '…';
                }
                
                ctx.fillStyle = color;
                ctx.fillText(displayLabel, screen.x, screen.y - h/2 + 5 * zoom);
            }
            
            // Namespace badge below label
            const nsFontSize = 9 * zoom;
            if (nsFontSize >= 5) {
                ctx.font = '400 ' + nsFontSize + 'px JetBrains Mono';
                ctx.fillStyle = 'rgba(98, 106, 115, 0.9)';
                ctx.textBaseline = 'top';
                ctx.fillText(node.data.namespace || '', screen.x, screen.y - h/2 + 5 * zoom + fontSize + 2 * zoom);
            }
        });
        
        // Draw port nodes (small rectangles on right side of workloads)
        portNodes.forEach(node => {
            if (!isFiniteNum(node.x) || !isFiniteNum(node.y)) return;
            
            const screen = worldToScreen(node.x, node.y);
            if (!isFiniteNum(screen.x) || !isFiniteNum(screen.y)) return;
            
            const isHovered = hoveredNode === node;
            const isSelected = selectedNode === node;
            const hasService = node.data.serviceName && node.data.serviceName !== '';
            
            // Wider port if it has a service name
            const baseWidth = hasService ? PORT_WIDTH * 3.5 : PORT_WIDTH;
            const w = baseWidth * zoom;
            const h = PORT_HEIGHT * zoom;
            const color = hasService ? '#82aaff' : colors.port; // Blue for service-backed ports
            
            // Glow for selected
            if (isSelected) {
                ctx.shadowColor = color;
                ctx.shadowBlur = 15;
            }
            
            // Port body
            ctx.beginPath();
            roundRect(ctx, screen.x - w/2, screen.y - h/2, w, h, 3 * zoom);
            
            ctx.fillStyle = (isSelected || isHovered) ? color + '60' : color + '30';
            ctx.fill();
            
            ctx.strokeStyle = (isSelected || isHovered) ? color : color + '80';
            ctx.lineWidth = isSelected ? 3 : (isHovered ? 2 : 1);
            ctx.stroke();
            
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            
            // Port text: show service name if available, otherwise port number
            const fontSize = 9 * zoom;
            if (fontSize >= 5) { // Only show if readable
                ctx.font = '500 ' + fontSize + 'px JetBrains Mono';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = color;
                
                if (hasService) {
                    // Show just service name, truncate if needed
                    let label = node.data.serviceName;
                    const maxWidth = w - 6 * zoom;
                    while (ctx.measureText(label).width > maxWidth && label.length > 3) {
                        label = label.slice(0, -2) + '…';
                    }
                    ctx.fillText(label, screen.x, screen.y);
                } else {
                    ctx.fillText(node.data.port || '', screen.x, screen.y);
                }
            }
        });
        
        drawMinimap();
        requestAnimationFrame(draw);
    }
    
    function roundRect(ctx, x, y, w, h, r) {
        ctx.beginPath();
        ctx.moveTo(x + r, y);
        ctx.lineTo(x + w - r, y);
        ctx.quadraticCurveTo(x + w, y, x + w, y + r);
        ctx.lineTo(x + w, y + h - r);
        ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
        ctx.lineTo(x + r, y + h);
        ctx.quadraticCurveTo(x, y + h, x, y + h - r);
        ctx.lineTo(x, y + r);
        ctx.quadraticCurveTo(x, y, x + r, y);
        ctx.closePath();
    }
    
    function drawMinimap() {
        minimapCtx.clearRect(0, 0, 180, 120);
        minimapCtx.fillStyle = 'rgba(18, 24, 32, 0.9)';
        minimapCtx.fillRect(0, 0, 180, 120);
        
        // Skip if no workload nodes
        if (workloadNodes.length === 0) {
            return;
        }
        
        // Find bounds (only from valid nodes)
        let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
        let validNodes = 0;
        workloadNodes.forEach(n => {
            if (isFiniteNum(n.x) && isFiniteNum(n.y)) {
                minX = Math.min(minX, n.x);
                maxX = Math.max(maxX, n.x);
                minY = Math.min(minY, n.y);
                maxY = Math.max(maxY, n.y);
                validNodes++;
            }
        });
        
        // Skip if no valid nodes
        if (validNodes === 0 || !isFiniteNum(minX) || !isFiniteNum(maxX)) {
            return;
        }
        
        const padding = 100;
        minX -= padding; maxX += padding;
        minY -= padding; maxY += padding;
        
        const rangeX = maxX - minX;
        const rangeY = maxY - minY;
        
        // Avoid division by zero
        if (rangeX <= 0 || rangeY <= 0) {
            return;
        }
        
        const scaleX = 180 / rangeX;
        const scaleY = 120 / rangeY;
        const scale = Math.min(scaleX, scaleY);
        
        const offsetX = (180 - rangeX * scale) / 2;
        const offsetY = (120 - rangeY * scale) / 2;
        
        // Draw nodes as small rectangles
        workloadNodes.forEach(n => {
            if (!isFiniteNum(n.x) || !isFiniteNum(n.y)) return;
            const x = (n.x - minX) * scale + offsetX;
            const y = (n.y - minY) * scale + offsetY;
            if (!isFiniteNum(x) || !isFiniteNum(y)) return;
            minimapCtx.fillStyle = colors[n.data.kind] || colors.Deployment;
            minimapCtx.fillRect(x - 3, y - 2, 6, 4);
        });
        
        // Draw viewport rectangle
        const viewMinWorld = screenToWorld(0, 0);
        const viewMaxWorld = screenToWorld(width, height);
        
        const vx = (viewMinWorld.x - minX) * scale + offsetX;
        const vy = (viewMinWorld.y - minY) * scale + offsetY;
        const vw = (viewMaxWorld.x - viewMinWorld.x) * scale;
        const vh = (viewMaxWorld.y - viewMinWorld.y) * scale;
        
        if (isFiniteNum(vx) && isFiniteNum(vy) && isFiniteNum(vw) && isFiniteNum(vh)) {
            minimapCtx.strokeStyle = 'rgba(57, 186, 230, 0.6)';
            minimapCtx.lineWidth = 1;
            minimapCtx.strokeRect(vx, vy, vw, vh);
        }
    }
    
    function findNodeAt(x, y) {
        const world = screenToWorld(x, y);
        
        // Check ports first (they're on top)
        for (const node of portNodes) {
            const hw = PORT_WIDTH / 2 + 5;
            const hh = PORT_HEIGHT / 2 + 5;
            if (Math.abs(world.x - node.x) < hw && Math.abs(world.y - node.y) < hh) {
                return node;
            }
        }
        
        // Check workloads (with dynamic height)
        for (const node of workloadNodes) {
            const hw = WORKLOAD_WIDTH / 2 + 5;
            const hh = (node.height || WORKLOAD_HEADER_HEIGHT) / 2 + 5;
            if (Math.abs(world.x - node.x) < hw && Math.abs(world.y - node.y) < hh) {
                return node;
            }
        }
        
        return null;
    }
    
    function findEdgeAt(x, y) {
        const world = screenToWorld(x, y);
        
        // Only check edges that are currently visible
        const visibleEdges = getVisibleEdges();
        
        for (const edge of visibleEdges) {
            const source = edge.sourceNode;
            const target = edge.targetNode;
            
            // Use the same coordinates as edge drawing
            const sourceHeight = source.height || WORKLOAD_HEADER_HEIGHT;
            const startX = source.x;
            const startY = source.y - sourceHeight / 2;
            const endX = target.x + PORT_WIDTH / 2;
            const endY = target.y;
            
            // Control points (same as drawing)
            const dx = endX - startX;
            const dy = endY - startY;
            const ctrl1X = startX;
            const ctrl1Y = startY - Math.abs(dy) * 0.3;
            const ctrl2X = endX + Math.abs(dx) * 0.3;
            const ctrl2Y = endY;
            
            // Sample points along the bezier curve and check distance
            const threshold = 15 / zoom; // Adjust threshold based on zoom
            for (let t = 0; t <= 1; t += 0.05) {
                const pt = bezierPoint(startX, startY, ctrl1X, ctrl1Y, ctrl2X, ctrl2Y, endX, endY, t);
                const dist = Math.sqrt(Math.pow(world.x - pt.x, 2) + Math.pow(world.y - pt.y, 2));
                if (dist < threshold) {
                    return edge;
                }
            }
        }
        return null;
    }
    
    // Calculate point on cubic bezier curve at t
    function bezierPoint(x0, y0, x1, y1, x2, y2, x3, y3, t) {
        const mt = 1 - t;
        const mt2 = mt * mt;
        const mt3 = mt2 * mt;
        const t2 = t * t;
        const t3 = t2 * t;
        return {
            x: mt3 * x0 + 3 * mt2 * t * x1 + 3 * mt * t2 * x2 + t3 * x3,
            y: mt3 * y0 + 3 * mt2 * t * y1 + 3 * mt * t2 * y2 + t3 * y3
        };
    }
    
    // Get currently visible edges based on selection/hover state
    function getVisibleEdges() {
        const visible = [];
        
        // Check selected node
        if (selectedNode) {
            if (selectedNode.data.type === 'workload') {
                edges.forEach(e => {
                    if (e.sourceNode.data.id === selectedNode.data.id || 
                        e.targetNode.data.parent === selectedNode.data.id) {
                        visible.push(e);
                    }
                });
            } else if (selectedNode.data.type === 'port') {
                edges.forEach(e => {
                    if (e.targetNode.data.id === selectedNode.data.id) {
                        visible.push(e);
                    }
                });
            }
        }
        
        return visible;
    }
    
    function showTooltip(x, y, content) {
        tooltip.innerHTML = content;
        tooltip.classList.add('visible');
        
        const rect = tooltip.getBoundingClientRect();
        let left = x + 15;
        let top = y + 15;
        
        if (left + rect.width > window.innerWidth) {
            left = x - rect.width - 15;
        }
        if (top + rect.height > window.innerHeight) {
            top = y - rect.height - 15;
        }
        
        tooltip.style.left = left + 'px';
        tooltip.style.top = top + 'px';
    }
    
    function hideTooltip() {
        tooltip.classList.remove('visible');
    }
    
    function getNodeTooltip(node) {
        const data = node.data;
        if (data.type === 'workload') {
            const badgeClass = 'badge-' + data.kind.toLowerCase();
            let html = '<div class="tooltip-title">' + data.label + 
                '<span class="tooltip-badge ' + badgeClass + '">' + data.kind + '</span></div>';
            html += '<div class="tooltip-row"><span class="tooltip-label">Namespace</span><span class="tooltip-value">' + data.namespace + '</span></div>';
            html += '<div class="tooltip-row"><span class="tooltip-label">ID</span><span class="tooltip-value">' + data.id + '</span></div>';
            
            if (data.metadata) {
                const labels = Object.entries(data.metadata).slice(0, 3);
                if (labels.length > 0) {
                    html += '<div class="tooltip-row"><span class="tooltip-label">Labels</span></div>';
                    labels.forEach(([k, v]) => {
                        html += '<div class="tooltip-row" style="padding-left: 12px;"><span class="tooltip-value" style="font-size: 11px;">' + k + '=' + v + '</span></div>';
                    });
                }
            }
            return html;
        } else {
            const isService = data.serviceName && data.serviceName !== '';
            const badgeLabel = isService ? 'Service' : 'Port';
            const title = isService ? data.serviceName : data.label;
            
            let html = '<div class="tooltip-title">' + title + 
                '<span class="tooltip-badge badge-port">' + badgeLabel + '</span></div>' +
                '<div class="tooltip-row"><span class="tooltip-label">Port</span><span class="tooltip-value">' + data.port + '</span></div>' +
                '<div class="tooltip-row"><span class="tooltip-label">Protocol</span><span class="tooltip-value">' + data.protocol + '</span></div>';
            
            if (isService && data.servicePort && data.servicePort !== data.port) {
                html += '<div class="tooltip-row"><span class="tooltip-label">Service Port</span><span class="tooltip-value">' + data.servicePort + '</span></div>';
            }
            
            html += '<div class="tooltip-row"><span class="tooltip-label">Workload</span><span class="tooltip-value">' + data.parent + '</span></div>';
            return html;
        }
    }
    
    function getEdgeTooltip(edge) {
        let html = '<div class="tooltip-title">Network Connection</div>';
        html += '<div class="tooltip-row"><span class="tooltip-label">From</span><span class="tooltip-value">' + edge.source + '</span></div>';
        html += '<div class="tooltip-row"><span class="tooltip-label">To</span><span class="tooltip-value">' + edge.target + '</span></div>';
        html += '<div class="tooltip-row"><span class="tooltip-label">Policy</span><span class="tooltip-value">' + edge.policy + '</span></div>';
        html += '<div class="tooltip-rule">' + edge.rule + '</div>';
        return html;
    }
    
    // Event handlers
    // Get all port nodes for a given workload
    function getPortsForWorkload(workloadNode) {
        return portNodes.filter(p => p.data.parent === workloadNode.data.id);
    }
    
    // Update port positions relative to their parent workload
    // Both services and ports on right side, right-aligned, hanging outside
    function updatePortPositions(workloadNode) {
        const ports = getPortsForWorkload(workloadNode);
        const portCount = ports.length || 1;
        
        updateWorkloadHeight(workloadNode, portCount);
        
        // Start ports a bit below the header rule (add 8px padding)
        const startY = workloadNode.y - workloadNode.height / 2 + WORKLOAD_HEADER_HEIGHT + 8 + PORT_HEIGHT / 2;
        
        // Right alignment point: workload right edge + 50% of port width
        const rightAlignX = workloadNode.x + WORKLOAD_WIDTH / 2 + PORT_WIDTH * 0.5;
        const serviceWidth = PORT_WIDTH * 3.5;
        
        ports.forEach((portNode, idx) => {
            const hasService = portNode.data.serviceName && portNode.data.serviceName !== '';
            const nodeWidth = hasService ? serviceWidth : PORT_WIDTH;
            
            // Position so right edge aligns with rightAlignX
            portNode.x = rightAlignX - nodeWidth / 2;
            portNode.y = startY + idx * (PORT_HEIGHT + PORT_GAP);
        });
    }
    
    let mouseDownTime = 0;
    let mouseDownNode = null;
    
    canvas.addEventListener('mousedown', (e) => {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        mouseDownTime = Date.now();
        const node = findNodeAt(x, y);
        mouseDownNode = node;
        
        if (node && node.data.type === 'workload') {
            isDragging = true;
            dragNode = node;
            dragNode.fixed = true;
            const world = screenToWorld(x, y);
            dragOffsetX = node.x - world.x;
            dragOffsetY = node.y - world.y;
        } else {
            isPanning = true;
            lastMouseX = x;
            lastMouseY = y;
        }
    });
    
    canvas.addEventListener('mousemove', (e) => {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        if (isDragging && dragNode) {
            const world = screenToWorld(x, y);
            dragNode.x = world.x + dragOffsetX;
            dragNode.y = world.y + dragOffsetY;
            // Move ports with the workload
            updatePortPositions(dragNode);
            // Keep dragNode as hovered during drag
            hoveredNode = dragNode;
        } else if (isPanning) {
            panX += x - lastMouseX;
            panY += y - lastMouseY;
            lastMouseX = x;
            lastMouseY = y;
        } else {
            const node = findNodeAt(x, y);
            const edge = node ? null : findEdgeAt(x, y);
            
            hoveredNode = node;
            hoveredEdge = edge;
            
            if (node) {
                showTooltip(e.clientX, e.clientY, getNodeTooltip(node));
                canvas.style.cursor = 'pointer';
            } else if (edge) {
                showTooltip(e.clientX, e.clientY, getEdgeTooltip(edge));
                canvas.style.cursor = 'pointer';
            } else {
                hideTooltip();
                canvas.style.cursor = 'grab';
            }
        }
    });
    
    canvas.addEventListener('mouseup', (e) => {
        const clickDuration = Date.now() - mouseDownTime;
        const wasClick = clickDuration < 200; // Less than 200ms = click, not drag
        
        if (wasClick && mouseDownNode) {
            // Toggle selection for workloads or ports
            if (selectedNode === mouseDownNode) {
                selectedNode = null; // Deselect
            } else {
                selectedNode = mouseDownNode; // Select
            }
            updateSelectionInfo();
        } else if (wasClick && !mouseDownNode) {
            // Clicked on empty space - deselect
            selectedNode = null;
            updateSelectionInfo();
        }
        
        if (dragNode) {
            dragNode.fixed = false;
        }
        isDragging = false;
        isPanning = false;
        dragNode = null;
        mouseDownNode = null;
    });
    
    function updateSelectionInfo() {
        const infoEl = document.getElementById('selection-info');
        if (selectedNode) {
            if (selectedNode.data.type === 'workload') {
                const outbound = edges.filter(e => e.sourceNode.data.id === selectedNode.data.id).length;
                const inbound = edges.filter(e => e.targetNode.data.parent === selectedNode.data.id).length;
                infoEl.textContent = selectedNode.data.label + ' (' + outbound + ' out, ' + inbound + ' in)';
            } else if (selectedNode.data.type === 'port') {
                const portId = selectedNode.data.id;
                const inbound = edges.filter(e => e.targetNode.data.id === portId).length;
                const label = selectedNode.data.serviceName || selectedNode.data.port;
                infoEl.textContent = label + ' (' + inbound + ' inbound)';
            }
            infoEl.style.display = 'block';
        } else {
            infoEl.style.display = 'none';
        }
    }
    
    canvas.addEventListener('mouseleave', () => {
        hideTooltip();
        if (dragNode) {
            dragNode.fixed = false;
        }
        isDragging = false;
        isPanning = false;
        dragNode = null;
    });
    
    canvas.addEventListener('wheel', (e) => {
        e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        const delta = e.deltaY > 0 ? 0.9 : 1.1;
        const newZoom = Math.min(Math.max(zoom * delta, 0.2), 5);
        
        // Zoom towards mouse position
        const world = screenToWorld(x, y);
        zoom = newZoom;
        panX = x - world.x * zoom;
        panY = y - world.y * zoom;
    });
    
    document.getElementById('search-input').addEventListener('input', (e) => {
        searchTerm = e.target.value;
    });
    
    function clearSelection() {
        selectedNode = null;
        updateSelectionInfo();
    }
    
    function toggleHoverEdges() {
        showEdgesOnHover = !showEdgesOnHover;
        document.getElementById('hover-edges-btn').textContent = 'Hover Edges: ' + (showEdgesOnHover ? 'ON' : 'OFF');
    }
    
    function resetView() {
        centerView();
    }
    
    function reLayout() {
        applyGridLayout();
        centerView();
    }
    
    function exportPNG() {
        const link = document.createElement('a');
        link.download = 'network-map.png';
        link.href = canvas.toDataURL('image/png');
        link.click();
    }
    
    // Initialize
    window.addEventListener('resize', resize);
    resize();
    
    // Function to center view on nodes
    function centerView() {
        if (workloadNodes.length > 0) {
            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            workloadNodes.forEach(n => {
                if (isFiniteNum(n.x) && isFiniteNum(n.y)) {
                    minX = Math.min(minX, n.x);
                    maxX = Math.max(maxX, n.x);
                    minY = Math.min(minY, n.y);
                    maxY = Math.max(maxY, n.y);
                }
            });
            if (isFiniteNum(minX) && isFiniteNum(maxX)) {
                const centerX = (minX + maxX) / 2;
                const centerY = (minY + maxY) / 2;
                
                // Adjust zoom to fit all nodes
                const graphWidth = maxX - minX + 200;
                const graphHeight = maxY - minY + 200;
                const zoomX = width / graphWidth;
                const zoomY = height / graphHeight;
                zoom = Math.min(zoomX, zoomY, 1); // Don't zoom in more than 1x
                zoom = Math.max(zoom, 0.1); // Don't zoom out too much
                
                panX = width / 2 - centerX * zoom;
                panY = height / 2 - centerY * zoom;
                console.log('dnmap: centered view, zoom:', zoom.toFixed(2));
            }
        }
    }
    
    // Center view after initial setup
    setTimeout(centerView, 100);
    
    draw();
    console.log('dnmap: initialization complete');
    } catch (e) {
        console.error('dnmap: ERROR:', e);
    }
    </script>
</body>
</html>

